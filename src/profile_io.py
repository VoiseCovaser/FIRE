"""Profile import/export helpers for web profile persistence."""

from __future__ import annotations

from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, Tuple


PROFILE_SCHEMA_VERSION = "1.0.0"
BUNDLE_KIND = "FIRE_BUNDLE"
SIMPLE_TWO_PHASE_MIN_POST_PENSION_INCOME = 17_500.0

# Only allow keys used by web params to avoid unsafe/unknown overrides.
ALLOWED_PROFILE_KEYS = {
    "setup_mode",
    "lock_profile_fields",
    "profile_name",
    "apply_profile_defaults",
    "patrimonio_inicial",
    "patrimonio_exact_mode",
    "aportacion_mensual",
    "aportacion_exact_mode",
    "edad_actual",
    "edad_objetivo",
    "rentabilidad_esperada",
    "volatilidad",
    "inflacion",
    "inflacionar_aportacion",
    "contribution_growth_rate",
    "gastos_anuales",
    "safe_withdrawal_rate",
    "fiscal_priority",
    "fiscal_mode",
    "regimen_fiscal",
    "include_optimización",
    "taxable_withdrawal_ratio_mode",
    "taxable_withdrawal_ratio",
    "tax_year",
    "region",
    "modo_guiado",
    "vivienda_habitual_valor",
    "vivienda_habitual_hipoteca",
    "incluir_cuota_vivienda_en_simulacion",
    "cuotas_hipoteca_vivienda_pendientes",
    "cuota_hipoteca_vivienda_mensual",
    "cuota_hipoteca_vivienda_mensual_exact_mode",
    "meses_hipoteca_vivienda_restantes",
    "meses_hipoteca_vivienda_restantes_exact_mode",
    "aplicar_ajuste_vivienda_habitual",
    "ahorro_vivienda_habitual_anual",
    "inmuebles_invertibles_valor",
    "inmuebles_invertibles_hipoteca",
    "incluir_cuota_inmuebles_en_simulacion",
    "cuotas_hipoteca_inmuebles_pendientes",
    "cuota_hipoteca_inmuebles_mensual",
    "cuota_hipoteca_inmuebles_mensual_exact_mode",
    "meses_hipoteca_inmuebles_restantes",
    "meses_hipoteca_inmuebles_restantes_exact_mode",
    "otras_deudas",
    "usar_capital_invertible_ampliado",
    "renta_bruta_alquiler_anual",
    "usar_modelo_avanzado_alquiler",
    "alquiler_costes_vacancia_pct",
    "alquiler_irpf_efectivo_pct",
    "incluir_rentas_alquiler_en_simulacion",
    "property_sale_enabled",
    "property_sale_phase",
    "property_sale_year_accumulation",
    "property_sale_year_retirement",
    "property_sale_amount",
    "property_sale_tax_calc_mode",
    "property_sale_capital_gain_pct",
    "property_sale_rent_drop_pct",
    "property_sale_remove_home_savings",
    "property_sale_purchase_year",
    "property_sale_purchase_price",
    "property_sale_purchase_costs",
    "property_sale_improvement_costs",
    "property_sale_selling_costs",
    "include_pension_in_simulation",
    "retirement_model_mode",
    "two_phase_switch_age",
    "two_phase_withdrawal_stage1_net_annual",
    "two_phase_withdrawal_stage2_net_annual",
    "two_phase_post_pension_income_annual",
    "two_stage_retirement_model",
    "edad_pension_oficial",
    "edad_inicio_pension_publica",
    "bonificacion_demora_pct",
    "pension_publica_neta_anual",
    "pension_publica_neta_anual_efectiva",
    "pension_neta_anual",
    "edad_inicio_plan_privado",
    "duracion_plan_privado_anos",
    "plan_pensiones_privado_neto_anual",
    "otras_rentas_post_jubilacion_netas",
    "coste_pre_pension_anual",
    "bootstrap_historical_strategy_label",
    "backtest_historical_strategy_label",
    "intl_tax_rates",
}


def serialize_profile(params: Dict[str, Any]) -> Dict[str, Any]:
    """Build portable JSON-serializable profile payload."""
    config: Dict[str, Any] = {}
    for key in ALLOWED_PROFILE_KEYS:
        if key in params:
            config[key] = params[key]
    return {
        "schema_version": PROFILE_SCHEMA_VERSION,
        "created_at": datetime.now(timezone.utc).isoformat(),
        "app_version": "web",
        "config": config,
    }


def serialize_unified_bundle(
    params: Dict[str, Any],
    *,
    scenario_meta: Optional[Dict[str, Any]] = None,
    scenario_summary: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """Build a single JSON schema for both profile-only and scenario exports.

    The payload keeps legacy mirrors (`config`, `params`, `meta`, `summary`) so
    old loaders can still parse files generated by newer versions.
    """
    profile_payload = serialize_profile(params)
    config = dict(profile_payload["config"])
    bundle: Dict[str, Any] = {
        "schema_version": PROFILE_SCHEMA_VERSION,
        "created_at": datetime.now(timezone.utc).isoformat(),
        "app_version": "web",
        "kind": BUNDLE_KIND,
        "profile": profile_payload,
        # Legacy profile mirror.
        "config": config,
    }

    include_scenario = scenario_meta is not None or scenario_summary is not None
    if include_scenario:
        meta = scenario_meta if isinstance(scenario_meta, dict) else {}
        summary = scenario_summary if isinstance(scenario_summary, dict) else {}
        bundle["scenario"] = {
            "meta": meta,
            "summary": summary,
        }
        # Legacy scenario mirrors.
        bundle["params"] = profile_payload
        bundle["meta"] = meta
        bundle["summary"] = summary

    return bundle


def derive_simple_two_phase_from_legacy(config: Dict[str, Any]) -> Dict[str, Any]:
    """Derive simple two-phase retirement fields from legacy advanced inputs."""
    def _as_float(key: str, default: float = 0.0) -> float:
        value = config.get(key, default)
        try:
            return float(value)
        except (TypeError, ValueError):
            return float(default)

    def _as_int(key: str, default: int = 0) -> int:
        value = config.get(key, default)
        try:
            return int(value)
        except (TypeError, ValueError):
            return int(default)

    gastos_anuales = _as_float("gastos_anuales", 0.0)
    coste_pre_pension = _as_float("coste_pre_pension_anual", 0.0)
    pension_publica_efectiva = _as_float(
        "pension_publica_neta_anual_efectiva",
        _as_float("pension_publica_neta_anual", 0.0),
    )
    plan_privado = _as_float("plan_pensiones_privado_neto_anual", 0.0)
    otras_rentas = _as_float("otras_rentas_post_jubilacion_netas", 0.0)

    edad_objetivo = _as_int("edad_objetivo", 67)
    edad_inicio_plan_privado = _as_int("edad_inicio_plan_privado", edad_objetivo)
    duracion_plan_privado = _as_int("duracion_plan_privado_anos", 0)
    pre_income_approx = plan_privado if (duracion_plan_privado > 0 and edad_inicio_plan_privado <= edad_objetivo) else 0.0

    switch_age_default = _as_int("edad_inicio_pension_publica", _as_int("edad_pension_oficial", 67))
    switch_age = max(50, min(100, switch_age_default))

    stage1 = max(0.0, gastos_anuales + coste_pre_pension - pre_income_approx)
    post_income = max(
        SIMPLE_TWO_PHASE_MIN_POST_PENSION_INCOME,
        pension_publica_efectiva + plan_privado + otras_rentas,
    )
    stage2 = max(0.0, gastos_anuales - post_income)
    return {
        "two_phase_switch_age": int(switch_age),
        "two_phase_withdrawal_stage1_net_annual": float(stage1),
        "two_phase_withdrawal_stage2_net_annual": float(stage2),
        "two_phase_post_pension_income_annual": float(post_income),
    }


def deserialize_profile(payload: Dict[str, Any]) -> Tuple[Dict[str, Any], List[str]]:
    """Parse and validate profile payload, returning safe config and warnings."""
    warnings: List[str] = []
    if not isinstance(payload, dict):
        return {}, ["Formato inválido: el perfil debe ser un objeto JSON."]

    normalized_payload = payload

    # Unified bundle: payload["profile"]["config"].
    profile_block = payload.get("profile")
    if isinstance(profile_block, dict):
        if isinstance(profile_block.get("config"), dict):
            normalized_payload = profile_block
            warnings.append("Archivo unificado detectado: se aplicará el bloque de perfil.")
        elif any(k in ALLOWED_PROFILE_KEYS for k in profile_block.keys()):
            normalized_payload = {
                "schema_version": payload.get("schema_version"),
                "config": profile_block,
            }
            warnings.append("Perfil detectado en formato compacto: se aplicará con compatibilidad.")

    # Legacy scenario wrapper: payload["params"]["config"].
    if (
        normalized_payload is payload
        and isinstance(payload.get("params"), dict)
        and isinstance(payload["params"].get("config"), dict)
    ):
        normalized_payload = payload["params"]
        warnings.append(
            "Archivo de escenario detectado: se aplicará su bloque de parámetros como perfil."
        )

    schema_version = normalized_payload.get("schema_version")
    if schema_version and schema_version != PROFILE_SCHEMA_VERSION:
        warnings.append(
            f"Versión de esquema distinta ({schema_version}); se intentará compatibilidad parcial."
        )

    raw_config = normalized_payload.get("config")
    if not isinstance(raw_config, dict):
        return {}, ["Formato inválido: falta bloque 'config'."]

    safe_config: Dict[str, Any] = {}
    for key, value in raw_config.items():
        if key in ALLOWED_PROFILE_KEYS:
            safe_config[key] = value
        else:
            warnings.append(f"Clave no reconocida ignorada: {key}")

    return safe_config, warnings
